---
alwaysApply: true
---

## 🚀 전문 개발자 코드 및 아키텍처 규칙

### I. 코드 스타일 및 구조

* **코드 작성:** 간결하고 기술적인 Typescript 코드를 작성하며, **Standard 규칙**을 엄격히 준수해야 합니다.
* **패턴:** 클래스 사용을 피하고 **함수형 및 선언적 프로그래밍** 패턴을 선호합니다.
* **재사용성:** 코드 복제(Duplication) 대신 반복(Iteration) 및 모듈화를 통해 코드의 효율성을 높여야 합니다.
* **변수명:** `isLoading`, `hasError`와 같은 보조 동사를 포함한 설명적인 변수명을 사용합니다.
* **명명 규칙:** 변수/함수는 `camelCase`, 컴포넌트는 `PascalCase`, 디렉토리는 소문자-대시를 사용합니다.

### II. 상태 및 데이터 관리 (Jotai & React-Query)

* **전역 상태 관리:** 전역 상태 관리에 **Jotai**를 사용합니다. 상태는 최소 단위의 **`atom`**으로 정의하여 선언적이고 효율적인 리렌더링을 유도합니다.
* **API/서버 상태:** 서버 상태 및 데이터 페칭 관리에 **React-Query**를 사용합니다. `useQuery`와 `useMutation` 훅을 활용하여 **캐싱, 재시도, 백그라운드 업데이트** 등 서버 데이터의 생명주기를 효과적으로 관리해야 합니다.
* **상태 생명주기:** React-Query로 서버 상태를, Jotai `atom`으로 클라이언트 상태를 관리하며, 컴포넌트의 라이프사이클과 분리하여 관리합니다.
* **URL 상태:** URL 검색 매개변수 상태 관리를 위해 'nuqs' 라이브러리를 사용합니다.

### III. 컴포넌트, 서비스 로직 분리 및 폴더 구조

* **관심사 분리 (SoC):** 컴포넌트는 **UI 렌더링**에만 집중해야 합니다. 모든 비즈니스 로직 및 데이터 페칭 로직은 컴포넌트 외부로 분리하는 것이 원칙입니다.
* **커스텀 훅 활용:** 재사용 가능한 로직뿐만 아니라, **복잡한 컴포넌트의 로직**을 **커스텀 훅**으로 추출하여 컴포넌트 파일을 간결하게 유지합니다.
* **서비스 로직 분리:** API 호출, 복잡한 비즈니스 계산 등 순수한 로직은 **`services/` 또는 `lib/`** 디렉토리에 **순수 함수** 형태로 분리하여 응집도를 높여야 합니다.
* **폴더 구조:** `app/`, `components/`, **`hooks/`**, **`stores/` (Jotai atoms)**, **`services/` (로직)**, **`lib/` (유틸리티)** 구조를 따릅니다.
* **컴포넌트 구조:** `components/ComponentName/` 폴더 내부에 `ComponentName.js`와 **`useComponentName.js` (로직 훅)**를 함께 배치합니다.

### IV. UI 및 스타일링 (Tailwind CSS v3 & Stylus)

* **기반 컴포넌트:** Shadcn UI 및 Radix UI를 컴포넌트 기반으로 사용하여 접근성과 재사용성을 확보합니다.
* **스타일링:** **Tailwind CSS v3**을 주력 유틸리티 스타일링 도구로 사용합니다.
* **하이브리드 접근:**
    * **Tailwind:** 레이아웃, 공통 유틸리티, 빠른 개발에 사용합니다.
    * **Stylus Modules:** 복잡하고 고유한 컴포넌트별 스타일 정의에만 사용합니다.
* **`@apply` 금지:** Tailwind의 `@apply` 지시문은 성능 및 유지보수 문제로 인해 사용하지 않습니다.
* **아이콘:** 아이콘이 필요할 경우 **`react-icons`** 라이브러리를 활용합니다.

### V. Next.js 최적화 및 코드 스플리팅

* **RSC 우선:** 'use client', `useEffect`, `useState` 사용을 최소화하고 **React Server Components (RSC)**를 최대한 활용하여 서버 렌더링을 극대화합니다.
* **코드 스플리팅:** 비필수적인 컴포넌트 및 클라이언트 컴포넌트 로딩 시 **`next/dynamic`**을 사용하여 컴포넌트 단위 코드 스플리팅을 구현합니다.
* **Suspense 활용:** 클라이언트 컴포넌트 로딩 및 데이터 페칭 시 **`Suspense`**로 감싸서 우아한 로딩 상태 (`fallback`)를 제공합니다.
* **웹 바이탈:** Web Vitals (LCP, CLS, FID) 최적화에 집중해야 합니다.

### VI. 에러 처리 및 유효성 검사

* **가드 패턴:** 함수 시작 부분에서 오류 및 엣지 케이스를 처리하는 **Guard Clauses**와 **Early Return**을 사용하여 중첩을 피하고 코드를 간결하게 유지합니다.
* **해피 패스:** 함수에서 정상적인 실행 경로("해피 패스") 코드를 마지막에 배치하여 가독성을 높입니다.
* **Server Actions:** 예상되는 오류를 Server Actions의 반환 값으로 모델링하여 클라이언트에서 처리할 수 있도록 합니다.
